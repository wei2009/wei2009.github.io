<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.15" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans|Marcellus+SC'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/custom.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/index.xml">

    
    <title>Android启动流程(4.4.4) - </title>
    <meta property='og:title' content="Android启动流程(4.4.4) - ">
    <meta property="og:type" content="article">
    

    <meta property="og:url" content="/post/2016/2016-05-27/">
    
    

  </head>

  <body>

    <header class="site">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href=""></a>
          </div>

          <div id="navbar" class="collapse navbar-collapse">
            
          </div>

        </div>
      </nav>
    </header>

    <div class="site">
      <div class="container">



<div class="single">

  <div class="row">
    <div class="col-md-8">

      <article class="single" itemscope="itemscope" itemtype="http://schema.org/Article">

        <meta itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" content=""/>
        <meta itemprop="dateModified" content="2016-05-27T02:13:01&#43;08:00">
        <meta itemprop="headline" content="Android启动流程(4.4.4)">
        <meta itemprop="description" content="Android启动流程(4.4.4) init 当Android手机开机以后，通常首先启动的是芯片内的bootloader，然后加载外部的bootloader，如Uboot之类。然后通过这些bootloader加载linux kernel。当linux kernel加载以后，然后调用第一个程序就是init。这个是Android的第一个进程。 在android手机上运行ps，1号进程就是init。 root@pisces:/ # ps ps USER PID PPID VSIZE RSS WCHAN PC NAME root 1 0 716 400 c014de6c 0001a9e8 S /init root 2 0 0 0 c0085340 00000000 S kthreadd root 3 2 0 0 c006bd90 00000000 S ksoftirqd/0 root 5 2 0 0 c00804ec 00000000 S kworker/0:0H 下面来看一下init做了哪些事情 http://androidxref.com/4.4.4_r1/xref/system/core/init/init.c 982 /* Get the basic filesystem setup we need put 983 * together in the initramdisk on / and then we&#39;ll 984 * let the rc file figure out the rest.">
        <meta itemprop="url" content="/post/2016/2016-05-27/">
        <div itemprop="image" itemscope itemtype="https://schema.org/ImageObject">
          <meta itemprop="url" content="images/default.jpg" />
          <meta itemprop="width" content="800">
          <meta itemprop="height" content="800">
        </div>
        <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
          <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <meta itemprop="url" content="images/logo.jpg">
            <meta itemprop="width" content="100">
            <meta itemprop="height" content="100">
          </div>
          <meta itemprop="name" content="">
        </div>
        <div itemprop="author" itemscope itemtype="https://schema.org/Person">
          <meta itemprop="name" content="">
        </div>

        <header class="article-header">
          <time itemprop="datePublished" pubdate="pubdate" datetime="2016-05-27T02:13:01&#43;08:00">Fri, May 27, 2016</time>
          <h1 class="article-title">Android启动流程(4.4.4)</h1>
        </header>

        <div class="article-body" itemprop="articleBody">
          

<h4 id="android启动流程-4-4-4:fdd6ada81b0db5bbcc8e39e3a34b071f">Android启动流程(4.4.4)</h4>

<h4 id="init:fdd6ada81b0db5bbcc8e39e3a34b071f">init</h4>

<ul>
<li>当Android手机开机以后，通常首先启动的是芯片内的bootloader，然后加载外部的bootloader，如Uboot之类。然后通过这些bootloader加载linux kernel。当linux kernel加载以后，然后调用第一个程序就是init。这个是Android的第一个进程。</li>

<li><p>在android手机上运行ps，1号进程就是init。</p>

<pre><code>root@pisces:/ # ps
ps
USER     PID   PPID  VSIZE  RSS     WCHAN    PC         NAME
root      1     0     716    400   c014de6c 0001a9e8 S /init
root      2     0     0      0     c0085340 00000000 S kthreadd
root      3     2     0      0     c006bd90 00000000 S ksoftirqd/0
root      5     2     0      0     c00804ec 00000000 S kworker/0:0H
</code></pre></li>

<li><p>下面来看一下init做了哪些事情</p></li>
</ul>

<pre><code class="language-cpp">http://androidxref.com/4.4.4_r1/xref/system/core/init/init.c

982        /* Get the basic filesystem setup we need put
983         * together in the initramdisk on / and then we'll
984         * let the rc file figure out the rest.
985         */
986    mkdir(&quot;/dev&quot;, 0755);
987    mkdir(&quot;/proc&quot;, 0755);
988    mkdir(&quot;/sys&quot;, 0755);
989
990    mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);
991    mkdir(&quot;/dev/pts&quot;, 0755);
992    mkdir(&quot;/dev/socket&quot;, 0755);
993    mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);
994    mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL);
995    mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL);
996
997        /* indicate that booting is in progress to background fw loaders, etc */
998    close(open(&quot;/dev/.booting&quot;, O_WRONLY | O_CREAT, 0000));
999
1000        /* We must have some place other than / to create the
1001         * device nodes for kmsg and null, otherwise we won't
1002         * be able to remount / read-only later on.
1003         * Now that tmpfs is mounted on /dev, we can actually
1004         * talk to the outside world.
1005         */
1006    open_devnull_stdio();
1007    klog_init();
1008    property_init();
1009
1010    get_hardware_name(hardware, &amp;revision);

........

1033    INFO(&quot;property init\n&quot;);
1034    if (!is_charger)
1035        property_load_boot_defaults();
1036
1037    INFO(&quot;reading config file\n&quot;);
1038    init_parse_config_file(&quot;/init.rc&quot;);
1039
1040    action_for_each_trigger(&quot;early-init&quot;, action_add_queue_tail);
1041
1042    queue_builtin_action(wait_for_coldboot_done_action, &quot;wait_for_coldboot_done&quot;);
1043    queue_builtin_action(mix_hwrng_into_linux_rng_action, &quot;mix_hwrng_into_linux_rng&quot;);
1044    queue_builtin_action(keychord_init_action, &quot;keychord_init&quot;);
1045    queue_builtin_action(console_init_action, &quot;console_init&quot;);
1046
1047    /* execute all the boot actions to get us started */
1048    action_for_each_trigger(&quot;init&quot;, action_add_queue_tail);
1049

........

1082    for(;;) {
1083        int nr, i, timeout = -1;
1084
1085        execute_one_command();
1086        restart_processes();
1087

........

1133
1134        for (i = 0; i &lt; fd_count; i++) {
1135            if (ufds[i].revents == POLLIN) {
1136                if (ufds[i].fd == get_property_set_fd())
1137                    handle_property_set_fd();
1138                else if (ufds[i].fd == get_keychord_fd())
1139                    handle_keychord();
1140                else if (ufds[i].fd == get_signal_fd())
1141                    handle_signal();
1142            }
1143        }
1144    }


</code></pre>

<ul>
<li>从Line 986 开始创建必要的文件系统目录。</li>
<li>Line 1007 开始初始化klog （/dev/<strong>kmsg</strong>）， 以及property （/dev/<strong>properties</strong>）。klog就是kernel log。 Android的属性，细看起来也可以写一大篇文章，这里就不分析了。简单的说，Android里面读属性，在各个进程里面从map的地址里面读。但是写属性是一个异步过程，都是通过socket将值传输到Line 1137，然后写属性，而且这里写属性还会进行权限的判断。所以，set property可能会失败。</li>
<li>重点来了，在 Line 1038， 这里初始化一个叫 init.rc的文件，先放在这里，后面再来分析。</li>
<li>从 Line 1040 开始，分别是将一些action加入队列，或者trigger一些action，这些都和init.rc有关。</li>
<li>从Line 1082开始 init进入死循环，然后执行command。这里init进程就执行完了。下面就开始分析前面我们略过的init.rc。具体解析init.rc的过程位于 <a href="http://androidxref.com/4.4.4_r1/xref/system/core/init/init_parser.c">http://androidxref.com/4.4.4_r1/xref/system/core/init/init_parser.c</a></li>
</ul>

<h4 id="init-rc:fdd6ada81b0db5bbcc8e39e3a34b071f">init.rc</h4>

<ul>
<li>init.rc里面实际上是一个简单的脚本，里面主要是两种格式</li>
<li>action的格式如下:</li>
</ul>

<pre><code>on &lt;trigger&gt;
  &lt;command&gt;
  &lt;command&gt;
  &lt;command&gt;
</code></pre>

<ul>
<li>service的格式如下：</li>
</ul>

<pre><code>services 的格式如下：
  service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*
  &lt;option&gt;
  &lt;option&gt;
  ... 
</code></pre>

<pre><code>http://androidxref.com/4.4.4_r1/xref/system/core/rootdir/init.rc

7   import /init.environ.rc
8   import /init.usb.rc
9   import /init.${ro.hardware}.rc
10  import /init.trace.rc

....

459 service servicemanager /system/bin/servicemanager
460    class core
461    user system
462    group system
463    critical
464    onrestart restart healthd
465    onrestart restart zygote
466    onrestart restart media
467    onrestart restart surfaceflinger
468    onrestart restart drm
469

497 service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
498    class main
499    socket zygote stream 660 root system
500    onrestart write /sys/android_power/request_state wake
501    onrestart write /sys/power/state on
502    onrestart restart media
503    onrestart restart netd

</code></pre>

<ul>
<li><p>在init.rc 里面启动的服务有很多，如console,adbd,netd,debuggerd等 这里重点列了两个最重要的服务，一个是servicemanager,其可执行文件位于 /system/bin/servicemanager，这个是给binder使用的。 另一个就是大名鼎鼎的zygote。</p></li>

<li><p>ServiceManager就涉及到Binder，Binder的内容也是一个复杂的东西，这里重点关注启动流程，看看zygote的设置内容。</p></li>

<li><p>从Line 497可以知道，zygote进程的执行文件位于/system/bin/app_process，后面的就是这个命令执行的参数“-Xzygote /system/bin &ndash;zygote &ndash;start-system-server&rdquo;</p></li>

<li><p>Line 498 设置了class 为main，这个class 名会被脚本里面的 class_start, class_stop使用。</p></li>

<li><p>Line 499 表明Zygote需要一个名为Zygote的 socket。等系统启动以后可以到 /dev/socket 这个目录下看到这个。</p></li>

<li><p>Line 500&ndash;503,分别是这两个进程重启以后会执行的命令。</p></li>
</ul>

<h4 id="zygote:fdd6ada81b0db5bbcc8e39e3a34b071f">Zygote</h4>

<ul>
<li>在zygote进程之前的这些进程都是linux进程，zygote之后我们就开始进入android世界，所有的android进程都来自于zygote。下面分析zygote的流程。</li>
</ul>

<pre><code class="language-cpp">http://androidxref.com/4.4.4_r1/xref/frameworks/base/cmds/app_process/app_main.cpp

138int main(int argc, char* const argv[])
139{

..........
166
167    // These are global variables in ProcessState.cpp
168    mArgC = argc;
169    mArgV = argv;
170
171    mArgLen = 0;
172    for (int i=0; i&lt;argc; i++) {
173        mArgLen += strlen(argv[i]) + 1;
174    }
175    mArgLen--;
176
177    AppRuntime runtime;
178    const char* argv0 = argv[0];
179
180    // Process command line arguments
181    // ignore argv[0]
182    argc--;
183    argv++;
184
185    // Everything up to '--' or first non '-' arg goes to the vm
186
187    int i = runtime.addVmArguments(argc, argv);
188
189    // Parse runtime arguments.  Stop at first unrecognized option.
190    bool zygote = false;
191    bool startSystemServer = false;
192    bool application = false;
193    const char* parentDir = NULL;
194    const char* niceName = NULL;
195    const char* className = NULL;
196    while (i &lt; argc) {
197        const char* arg = argv[i++];
198        if (!parentDir) {
199            parentDir = arg;
200        } else if (strcmp(arg, &quot;--zygote&quot;) == 0) {
201            zygote = true;
202            niceName = &quot;zygote&quot;;
203        } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) {
204            startSystemServer = true;
205        } else if (strcmp(arg, &quot;--application&quot;) == 0) {
206            application = true;
207        } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) {
208            niceName = arg + 12;
209        } else {
210            className = arg;
211            break;
212        }
213    }
214
215    if (niceName &amp;&amp; *niceName) {
216        setArgv0(argv0, niceName);
217        set_process_name(niceName);
218    }
219
220    runtime.mParentDir = parentDir;
221
222    if (zygote) {
223        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,
224                startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);
225    } else if (className) {
226        // Remainder of args get passed to startup class main()
227        runtime.mClassName = className;
228        runtime.mArgC = argc - i;
229        runtime.mArgV = argv + i;
230        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;,
231                application ? &quot;application&quot; : &quot;tool&quot;);
232    } else {
233        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);
234        app_usage();
235        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);
236        return 10;
237    }
238}

</code></pre>

<ul>
<li>前面init.rc里面写的，zygote也就是app_process执行的参数是 “-Xzygote /system/bin &ndash;zygote &ndash;start-system-server&rdquo;</li>
<li>Line 182&mdash;183 忽略了第一个参数。</li>
<li>Line 196&mdash;213 这一部分处理后面的参数，代码很简单，结果就是</li>
<li>parentDir = /system/bin</li>
<li>zygote = true;</li>
<li>niceName = &ldquo;zygote&rdquo;;</li>

<li><p>startSystemServer = true;</p></li>

<li><p>Line 215&mdash;218 设置进程名为zygote。</p></li>

<li><p>然后执行到了 Line 223&mdash;224，这就是这个函数主要的作用</p></li>
</ul>

<pre><code class="language-cpp">runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, &quot;start-system-server&quot; );
</code></pre>

<ul>
<li>下面来看一下runtime的执行。</li>
</ul>

<pre><code class="language-cpp">
32class AppRuntime : public AndroidRuntime
33{
34public:

</code></pre>

<pre><code class="language-cpp">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/jni/AndroidRuntime.cpp


232AndroidRuntime::AndroidRuntime() :
233        mExitWithoutCleanup(false)
234{
............
249
250    assert(gCurRuntime == NULL);        // one per process
251    gCurRuntime = this;
252}



805void AndroidRuntime::start(const char* className, const char* options)
806{
807    ALOGD(&quot;\n&gt;&gt;&gt;&gt;&gt;&gt; AndroidRuntime START %s &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;,
808            className != NULL ? className : &quot;(unknown)&quot;);
809
810    /*
811     * 'startSystemServer == true' means runtime is obsolete and not run from
812     * init.rc anymore, so we print out the boot start event here.
813     */
814    if (strcmp(options, &quot;start-system-server&quot;) == 0) {
815        /* track our progress through the boot sequence */
816        const int LOG_BOOT_PROGRESS_START = 3000;
817        LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,
818                       ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));
819    }
820
821    const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;);
822    if (rootDir == NULL) {
823        rootDir = &quot;/system&quot;;
824        if (!hasDir(&quot;/system&quot;)) {
825            LOG_FATAL(&quot;No root directory specified, and /android does not exist.&quot;);
826            return;
827        }
828        setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1);
829    }
830
831    //const char* kernelHack = getenv(&quot;LD_ASSUME_KERNEL&quot;);
832    //ALOGD(&quot;Found LD_ASSUME_KERNEL='%s'\n&quot;, kernelHack);
833
834    /* start the virtual machine */
835    JniInvocation jni_invocation;
836    jni_invocation.Init(NULL);
837    JNIEnv* env;
838    if (startVm(&amp;mJavaVM, &amp;env) != 0) {
839        return;
840    }
841    onVmCreated(env);
842
843    /*
844     * Register android functions.
845     */
846    if (startReg(env) &lt; 0) {
847        ALOGE(&quot;Unable to register all android natives\n&quot;);
848        return;
849    }
850
851    /*
852     * We want to call main() with a String array with arguments in it.
853     * At present we have two arguments, the class name and an option string.
854     * Create an array to hold them.
855     */
856    jclass stringClass;
857    jobjectArray strArray;
858    jstring classNameStr;
859    jstring optionsStr;
860
861    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);
862    assert(stringClass != NULL);
863    strArray = env-&gt;NewObjectArray(2, stringClass, NULL);
864    assert(strArray != NULL);
865    classNameStr = env-&gt;NewStringUTF(className);
866    assert(classNameStr != NULL);
867    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);
868    optionsStr = env-&gt;NewStringUTF(options);
869    env-&gt;SetObjectArrayElement(strArray, 1, optionsStr);
870
871    /*
872     * Start VM.  This thread becomes the main thread of the VM, and will
873     * not return until the VM exits.
874     */
875    char* slashClassName = toSlashClassName(className);
876    jclass startClass = env-&gt;FindClass(slashClassName);
877    if (startClass == NULL) {
878        ALOGE(&quot;JavaVM unable to locate class '%s'\n&quot;, slashClassName);
879        /* keep going */
880    } else {
881        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,
882            &quot;([Ljava/lang/String;)V&quot;);
883        if (startMeth == NULL) {
884            ALOGE(&quot;JavaVM unable to find main() in '%s'\n&quot;, className);
885            /* keep going */
886        } else {
887            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);
888
889#if 0
890            if (env-&gt;ExceptionCheck())
891                threadExitUncaughtException(env);
892#endif
893        }
894    }
895    free(slashClassName);
896
897    ALOGD(&quot;Shutting down VM\n&quot;);
898    if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)
899        ALOGW(&quot;Warning: unable to detach main thread\n&quot;);
900    if (mJavaVM-&gt;DestroyJavaVM() != 0)
901        ALOGW(&quot;Warning: VM did not shut down cleanly\n&quot;);
902}
903

..........

1256AndroidRuntime* AndroidRuntime::getRuntime()
1257{
1258    return gCurRuntime;
1259}

</code></pre>

<ul>
<li>AppRuntime继承自AndroidRuntime. start()函数定义在AdroidRuntime中。</li>
<li>Line 807的 log就是我们判断zygote启动的log。如果发生zygote重启，也可以看是否有这条log。</li>
<li>Line 834&mdash;850 就是启动了dalvik虚拟机,并且注册了JNI.</li>
<li>Line 897&mdash;902 就是关掉这个虚拟机。也就是说zygote正常运行是不会运行到这里来的。</li>
<li>Line 856&mdash;895 就是通过jni 在C里面调用 一个类为className的 “main”， 参数是一个array，内容是options。通过前面的传入的参数，我们知道也即是执行了java类：com.android.internal.os.ZygoteInit的 main方法，参数为 “start-system-server”。</li>
<li>下面就正式进入了java世界了。是不是很激动 :)</li>
</ul>

<h4 id="zygoteinit:fdd6ada81b0db5bbcc8e39e3a34b071f">ZygoteInit</h4>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java

561
562    public static void main(String argv[]) {
563        try {
564            // Start profiling the zygote initialization.
565            SamplingProfilerIntegration.start();
566
567            registerZygoteSocket();
568            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
569                SystemClock.uptimeMillis());
570            preload();
571            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
572                SystemClock.uptimeMillis());
573
574            // Finish profiling the zygote initialization.
575            SamplingProfilerIntegration.writeZygoteSnapshot();
576
577            // Do an initial gc to clean up after startup
578            gc();
579
580            // Disable tracing so that forked processes do not inherit stale tracing tags from
581            // Zygote.
582            Trace.setTracingEnabled(false);
583
584            // If requested, start system server directly from Zygote
585            if (argv.length != 2) {
586                throw new RuntimeException(argv[0] + USAGE_STRING);
587            }
588
589            if (argv[1].equals(&quot;start-system-server&quot;)) {
590                startSystemServer();
591            } else if (!argv[1].equals(&quot;&quot;)) {
592                throw new RuntimeException(argv[0] + USAGE_STRING);
593            }
594
595            Log.i(TAG, &quot;Accepting command socket connections&quot;);
596
597            runSelectLoop();
598
599            closeServerSocket();
600        } catch (MethodAndArgsCaller caller) {
601            caller.run();
602        } catch (RuntimeException ex) {
603            Log.e(TAG, &quot;Zygote died with exception&quot;, ex);
604            closeServerSocket();
605            throw ex;
606        }
607    }
608

</code></pre>

<ul>
<li>Line 567  这里会执行 registerZygoteSocket();</li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java

68    private static final String ANDROID_SOCKET_ENV = &quot;ANDROID_SOCKET_zygote&quot;;

154    private static void registerZygoteSocket() {
155        if (sServerSocket == null) {
156            int fileDesc;
157            try {
158                String env = System.getenv(ANDROID_SOCKET_ENV);
159                fileDesc = Integer.parseInt(env);
160            } catch (RuntimeException ex) {
161                throw new RuntimeException(
162                        ANDROID_SOCKET_ENV + &quot; unset or invalid&quot;, ex);
163            }
164
165            try {
166                sServerSocket = new LocalServerSocket(
167                        createFileDescriptor(fileDesc));
168            } catch (IOException ex) {
169                throw new RuntimeException(
170                        &quot;Error binding to local socket '&quot; + fileDesc + &quot;'&quot;, ex);
171            }
172        }
173    }

</code></pre>

<ul>
<li>这里首先会取一个环境变量ANDROID_SOCKET_ENV，而这个环境变量怎么来的呢，这里又要回到我们init.rc里，关于 service zygote里面关于socket的选项： “socket zygote stream 660 root system”， init在service_start(&hellip;)里fork以后，会把这个环境变量通过publish_socket加入到环境变量，这个环境变量里保存的就是/dev/socket/zygote的文件描述符。那么这里zygoteInit就创建了这个文件描述符的 LocalServerSocket。</li>
<li>回到ZygoteInit，我们先接着这个socket看 Line 597， 在这里，runSelectLoop也会进入一个while(true)循环，然后会等待socket。这里就涉及到Activity的启动，也是在ActivityManagerService里面通过socket将进程的信息传递到这里，然后ZygoteInit收到进程信息，从而fork进程。最后会走到ZygoteConnction,</li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java


165    boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
166
.,.............
223            pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
224                    parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
225                    parsedArgs.niceName);
226        } catch (IOException ex) {

</code></pre>

<ul>
<li><p>Zygote的forkAndSpecialize最后会通过jni调用到 dalvik_system_Zygote.cpp里面的forkAndSpecializeCommon，在这个里面还会设置传递过来的gid，uid等参数，从而保证Activity进程间不同资源访问的安全性。</p></li>

<li><p>再次回到ZygoteInit::main,来看看我们尚未分析的函数。</p></li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java

236    static void preload() {
237        preloadClasses();
238        preloadResources();
239        preloadOpenGL();
240    }



492    /**
493     * Prepare the arguments and fork for the system server process.
494     */
495    private static boolean startSystemServer()
496            throws MethodAndArgsCaller, RuntimeException {
497        long capabilities = posixCapabilitiesAsBits(
498            OsConstants.CAP_KILL,
499            OsConstants.CAP_NET_ADMIN,
500            OsConstants.CAP_NET_BIND_SERVICE,
501            OsConstants.CAP_NET_BROADCAST,
502            OsConstants.CAP_NET_RAW,
503            OsConstants.CAP_SYS_MODULE,
504            OsConstants.CAP_SYS_NICE,
505            OsConstants.CAP_SYS_RESOURCE,
506            OsConstants.CAP_SYS_TIME,
507            OsConstants.CAP_SYS_TTY_CONFIG
508        );
509        /* Hardcoded command line to start the system server */
510        String args[] = {
511            &quot;--setuid=1000&quot;,
512            &quot;--setgid=1000&quot;,
513            &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,
514            &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,
515            &quot;--runtime-init&quot;,
516            &quot;--nice-name=system_server&quot;,
517            &quot;com.android.server.SystemServer&quot;,
518        };
519        ZygoteConnection.Arguments parsedArgs = null;
520
521        int pid;
522
523        try {
524            parsedArgs = new ZygoteConnection.Arguments(args);
525            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
526            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);
527
528            /* Request to fork the system server process */
529            pid = Zygote.forkSystemServer(
530                    parsedArgs.uid, parsedArgs.gid,
531                    parsedArgs.gids,
532                    parsedArgs.debugFlags,
533                    null,
534                    parsedArgs.permittedCapabilities,
535                    parsedArgs.effectiveCapabilities);
536        } catch (IllegalArgumentException ex) {
537            throw new RuntimeException(ex);
538        }
539
540        /* For child process */
541        if (pid == 0) {
542            handleSystemServerProcess(parsedArgs);
543        }
544
545        return true;
546    }

</code></pre>

<ul>
<li>preload 函数会加载公共的class以及资源，这些会在fork的时候，每一个应用程序不需要再次加载这些公共库，从而加快应用启动速度。</li>
<li>最后回到 startSystemServer(&hellip;) 这个函数，这个里面重点就是 执行 Zygote.forkSystemServer然后，fork出来的systemServer进程执行handleSystemServerProcess， 而Zygote进程则继续我们前面分析过的执行runSelectLoop() 然后等在socket那里等着不断fork出一个有一个进程。Zygote进程执行的内容这里就分析完了。下面进入一个非常重要的进程SystemServer.</li>
</ul>

<h4 id="systemserver:fdd6ada81b0db5bbcc8e39e3a34b071f">SystemServer.</h4>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java

465    private static void handleSystemServerProcess(
466            ZygoteConnection.Arguments parsedArgs)
467            throws ZygoteInit.MethodAndArgsCaller {
468
469        closeServerSocket();
470
471        // set umask to 0077 so new files and directories will default to owner-only permissions.
472        Libcore.os.umask(S_IRWXG | S_IRWXO);
473
474        if (parsedArgs.niceName != null) {
475            Process.setArgV0(parsedArgs.niceName);
476        }
477
478        if (parsedArgs.invokeWith != null) {
479            WrapperInit.execApplication(parsedArgs.invokeWith,
480                    parsedArgs.niceName, parsedArgs.targetSdkVersion,
481                    null, parsedArgs.remainingArgs);
482        } else {
483            /*
484             * Pass the remaining arguments to SystemServer.
485             */
486            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);
487        }
488
489        /* should never reach here */
490    }
</code></pre>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java

261    public static final void zygoteInit(int targetSdkVersion, String[] argv)
262            throws ZygoteInit.MethodAndArgsCaller {
263        if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;);
264
265        redirectLogStreams();
266
267        commonInit();
268        nativeZygoteInit();
269
270        applicationInit(targetSdkVersion, argv);
271    }
</code></pre>

<pre><code class="language-cpp">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/jni/AndroidRuntime.cpp#com_android_internal_os_RuntimeInit_nativeZygoteInit

198static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
199{
200    gCurRuntime-&gt;onZygoteInit();
201}
202

</code></pre>

<pre><code class="language-cpp">http://androidxref.com/4.4.4_r1/xref/frameworks/base/cmds/app_process/app_main.cpp

98    virtual void onZygoteInit()
99    {
100        // Re-enable tracing now that we're no longer in Zygote.
101        atrace_set_tracing_enabled(true);
102
103        sp&lt;ProcessState&gt; proc = ProcessState::self();
104        ALOGV(&quot;App process: starting thread pool.\n&quot;);
105        proc-&gt;startThreadPool();
106    }
107
</code></pre>

<ul>
<li>这里又执行到了RuntimeInit.zygoteInit，其中nativeZygoteInit 最终会调用到 AppRuntime::onZygoteInit(), 这段代码，如果熟悉Binder的话，就很清楚，就是初始化Binder,这里就不多说了。</li>
<li>下面再看applicationInit(targetSdkVersion, argv);</li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java


291    private static void applicationInit(int targetSdkVersion, String[] argv)
292            throws ZygoteInit.MethodAndArgsCaller {
293        // If the application calls System.exit(), terminate the process
294        // immediately without running any shutdown hooks.  It is not possible to
295        // shutdown an Android application gracefully.  Among other things, the
296        // Android runtime shutdown hooks close the Binder driver, which can cause
297        // leftover running threads to crash before the process actually exits.
298        nativeSetExitWithoutCleanup(true);
299
300        // We want to be fairly aggressive about heap utilization, to avoid
301        // holding on to a lot of memory that isn't needed.
302        VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);
303        VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);
304
305        final Arguments args;
306        try {
307            args = new Arguments(argv);
308        } catch (IllegalArgumentException ex) {
309            Slog.e(TAG, ex.getMessage());
310            // let the process exit
311            return;
312        }
313
314        // Remaining arguments are passed to the start class's static main
315        invokeStaticMain(args.startClass, args.startArgs);
316    }
317
</code></pre>

<ul>
<li>最后执行的class是什么呢? 回头看参数</li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java#startSystemServer


509        /* Hardcoded command line to start the system server */
510        String args[] = {
511            &quot;--setuid=1000&quot;,
512            &quot;--setgid=1000&quot;,
513            &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,
514            &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,
515            &quot;--runtime-init&quot;,
516            &quot;--nice-name=system_server&quot;,
517            &quot;com.android.server.SystemServer&quot;,
518        };

</code></pre>

<ul>
<li>要执行SystemServer, 再看看invokeStaticMain是如何执行SystemServer的，</li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java

191    private static void invokeStaticMain(String className, String[] argv)
192            throws ZygoteInit.MethodAndArgsCaller {
193        Class&lt;?&gt; cl;
194
195        try {
196            cl = Class.forName(className);
197        } catch (ClassNotFoundException ex) {
198            throw new RuntimeException(
199                    &quot;Missing class when invoking static main &quot; + className,
200                    ex);
201        }
202
203        Method m;
204        try {
205            m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });
206        } catch (NoSuchMethodException ex) {
207            throw new RuntimeException(
208                    &quot;Missing static main on &quot; + className, ex);
209        } catch (SecurityException ex) {
210            throw new RuntimeException(
211                    &quot;Problem getting static main on &quot; + className, ex);
212        }
213
214        int modifiers = m.getModifiers();
215        if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {
216            throw new RuntimeException(
217                    &quot;Main method is not public and static on &quot; + className);
218        }
219
220        /*
221         * This throw gets caught in ZygoteInit.main(), which responds
222         * by invoking the exception's run() method. This arrangement
223         * clears up all the stack frames that were required in setting
224         * up the process.
225         */
226        throw new ZygoteInit.MethodAndArgsCaller(m, argv);
227    }

</code></pre>

<ul>
<li>注意，这里并没有直接执行SystemServer的函数，而是直接抛一个异常，这个异常在哪里被接住呢？回头看ZygoteInit。</li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java


600        } catch (MethodAndArgsCaller caller) {
601            caller.run();
</code></pre>

<ul>
<li></li>

<li><p>这下执行的是 com.android.server.SystemServer.</p></li>
</ul>

<pre><code class="language-java">http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/java/com/android/server/SystemServer.java


1125    public static void main(String[] args) {
1126
.............
1165        VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);
1166
1167        Environment.setUserRequired(true);
1168
1169        System.loadLibrary(&quot;android_servers&quot;);
1170
1171        Slog.i(TAG, &quot;Entered the Android system server!&quot;);
1172
1173        // Initialize native services.
1174        nativeInit();
1175
1176        // This used to be its own separate thread, but now it is
1177        // just the loop we run on the main thread.
1178        ServerThread thr = new ServerThread();
1179        thr.initAndLoop();
1180    }
1181}
1182

</code></pre>

<pre><code class="language-cpp">http://androidxref.com/4.4.4_r1/xref/frameworks/base/services/jni/com_android_server_SystemServer.cpp

28static void android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) {
29    char propBuf[PROPERTY_VALUE_MAX];
30    property_get(&quot;system_init.startsensorservice&quot;, propBuf, &quot;1&quot;);
31    if (strcmp(propBuf, &quot;1&quot;) == 0) {
32        // Start the sensor service
33        SensorService::instantiate();
34    }
35}
</code></pre>

<ul>
<li>nativeInit最终执行到 startSensorService.</li>
</ul>

<pre><code class="language-java">92    public void initAndLoop() {
93        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN,
94            SystemClock.uptimeMillis());
95
96        Looper.prepareMainLooper();
97
98        android.os.Process.setThreadPriority(
99                android.os.Process.THREAD_PRIORITY_FOREGROUND);

..............

195            Slog.i(TAG, &quot;Activity Manager&quot;);
196            context = ActivityManagerService.main(factoryTest);
.......

241            pm = PackageManagerService.main(context, installer,
242                    factoryTest != SystemServer.FACTORY_TEST_OFF,
243                    onlyCore);
244            try {
245                firstBoot = pm.isFirstBoot();
246            } catch (RemoteException e) {
247            }
248
249            ActivityManagerService.setSystemProcess();
.....

938        ActivityManagerService.self().systemReady(new Runnable() {
939            public void run() {
940                Slog.i(TAG, &quot;Making services ready&quot;);
941
942                try {
943                    ActivityManagerService.self().startObservingNativeCrashes();
944                } catch (Throwable e) {
945                    reportWtf(&quot;observing native crashes&quot;, e);
946                }
947                if (!headless) {
948                    startSystemUi(contextF);
949                }

.....................
1085            }
1086        });
1087
1088        // For debug builds, log event loop stalls to dropbox for analysis.
1089        if (StrictMode.conditionallyEnableDebugLogging()) {
1090            Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;);
1091        }
1092
1093        Looper.loop();
1094        Slog.d(TAG, &quot;System ServerThread is exiting!&quot;);

</code></pre>

<ul>
<li>thr.initAndLoop();里面会启动各种java service。注意这里的ServerThread不是一个Thread，只是一个类名，执行的还是在主线程，执行到最后会执行 Line 1093 进入Looper。</li>

<li><p>基本上我们知道的重要的service基本上都是在thr.initAndLoop里面启动的，包括AMS, PMS等。</p></li>

<li><p>在AMS的SystemReady最后会执行。             mStackSupervisor.resumeTopActivitiesLocked(); 当前没有TopActivity，会启动launcher。</p></li>

<li></li>
</ul>

        </div>


        <aside>
          

          <div class="section share">
            <a href="http://www.facebook.com/sharer.php?src=bm&u=%2fpost%2f2016%2f2016-05-27%2f&t=Android%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b%284.4.4%29" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-facebook"></i></a>
            <a href="http://twitter.com/intent/tweet?url=%2fpost%2f2016%2f2016-05-27%2f&text=Android%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b%284.4.4%29&tw_p=tweetbutton" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-twitter"></i></a>
            <a href="https://plus.google.com/share?url=%2fpost%2f2016%2f2016-05-27%2f" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-google-plus"></i></a>
            <a href="http://getpocket.com/edit?url=%2fpost%2f2016%2f2016-05-27%2f&title=Android%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b%284.4.4%29" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-get-pocket"></i></a>
          </div>

          
          
          
        </aside>

      </article>

    </div>
    <div class="col-md-4">
      
<aside class="site">

  <div class="panel panel-default">
    <div class="panel-heading">
      <h2 class="panel-title">LatestPosts</h2>
    </div>
    <div class="list-group">
      
      <a href="/post/2016/2016-05-27/" class="list-group-item">Android启动流程(4.4.4)</a>
      
    </div>
  </div>

  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h2 class="panel-title">category</h2>
    </div>
    <div class="list-group">
      
    </div>
  </div>
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h2 class="panel-title">tag</h2>
    </div>
    <div class="list-group">
      
    </div>
  </div>
  

</aside>


    </div>
  </div>

</div>

      </div>
    </div>

    <footer class="site">
      <div class="container">
        <p>&copy; 2016 </p>
        <p>Powered by <a href="http://gohugo.io" target="_blank" rel="nofollow">Hugo</a>, Theme <a href="https://github.com/dim0627/hugo_theme_beg" target="_blank" rel="nofollow">beg</a> designed by <a href="http://yet.unresolved.xyz" target="_blank" rel="nofollow">Daisuke Tsuji</a></p>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-2.2.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    

  </body>
</html>

